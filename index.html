<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>JavaScript Bridge Demo</title>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            padding: 16px;
            background: #f5f5f5;
            line-height: 1.6;
        }

        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 20px;
            border-radius: 12px;
            margin-bottom: 20px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }

        .header h1 {
            font-size: 24px;
            margin-bottom: 8px;
        }

        .header p {
            font-size: 14px;
            opacity: 0.9;
        }

        .status {
            background: white;
            padding: 12px 16px;
            border-radius: 8px;
            margin-bottom: 20px;
            display: flex;
            align-items: center;
            gap: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
        }

        .status-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: #10b981;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .section {
            background: white;
            padding: 16px;
            border-radius: 12px;
            margin-bottom: 16px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
        }

        .section h2 {
            color: #1f2937;
            font-size: 18px;
            margin-bottom: 12px;
            padding-bottom: 8px;
            border-bottom: 2px solid #e5e7eb;
        }

        .button-group {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
            gap: 8px;
            margin-top: 12px;
        }

        button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 12px 16px;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: transform 0.1s, box-shadow 0.1s;
            box-shadow: 0 2px 4px rgba(102, 126, 234, 0.3);
        }

        button:active {
            transform: translateY(1px);
            box-shadow: 0 1px 2px rgba(102, 126, 234, 0.3);
        }

        button:disabled {
            background: #9ca3af;
            cursor: not-allowed;
            box-shadow: none;
        }

        .console {
            background: #1f2937;
            color: #10b981;
            padding: 16px;
            border-radius: 8px;
            font-family: 'Courier New', Courier, monospace;
            font-size: 12px;
            max-height: 300px;
            overflow-y: auto;
            line-height: 1.5;
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.2);
        }

        .console-entry {
            margin-bottom: 8px;
            padding: 4px 0;
            border-bottom: 1px solid #374151;
        }

        .console-entry:last-child {
            border-bottom: none;
        }

        .timestamp {
            color: #6b7280;
            margin-right: 8px;
        }

        .success {
            color: #10b981;
        }

        .error {
            color: #ef4444;
        }

        .info {
            color: #3b82f6;
        }

        .warning {
            color: #f59e0b;
        }

        .clear-console {
            background: #374151;
            color: #9ca3af;
            padding: 8px 16px;
            margin-top: 8px;
            font-size: 12px;
        }

        .test-section {
            background: #fef3c7;
            border: 2px solid #fbbf24;
            padding: 12px;
            border-radius: 8px;
            margin-top: 12px;
        }

        .test-section h3 {
            color: #92400e;
            font-size: 14px;
            margin-bottom: 8px;
        }

        pre {
            background: #f3f4f6;
            padding: 12px;
            border-radius: 6px;
            overflow-x: auto;
            font-size: 11px;
            margin-top: 8px;
        }

        .device-info {
            background: #f0fdf4;
            border: 1px solid #86efac;
            padding: 12px;
            border-radius: 8px;
            margin-top: 12px;
        }

        .device-info-item {
            display: flex;
            justify-content: space-between;
            padding: 4px 0;
            font-size: 13px;
        }

        .device-info-item strong {
            color: #166534;
        }

        .device-info-item span {
            color: #15803d;
        }

        /* Inline code badge for compact, non-breaking tokens */
        code.badge {
            background: #eef2ff; /* indigo-50 */
            color: #3730a3;      /* indigo-800 */
            padding: 2px 8px;
            border-radius: 9999px;
            font-size: 12px;
            white-space: nowrap; /* avoid breaking schema token on mobile */
        }
        .device-info-subtext {
            color: #6b7280; /* gray-500 */
            font-size: 12px;
        }
        .flex-col {
            display: flex;
            flex-direction: column;
            align-items: flex-end;
            gap: 4px;
        }

        /* Collapsible docs styling */
        .collapsible {
            width: 100%;
        }
        .collapsible summary {
            list-style: none;
            cursor: pointer;
            font-weight: 600;
            color: #1f2937;
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 0;
        }
        .collapsible summary::-webkit-details-marker { display: none; }
        .collapsible summary:after {
            content: '▸';
            margin-left: auto;
            color: #9ca3af;
            transition: transform 0.15s ease-in-out;
        }
        .collapsible[open] summary:after {
            transform: rotate(90deg);
        }
        .collapsible-content {
            border-top: 2px solid #e5e7eb;
            margin-top: 8px;
            padding-top: 12px;
        }
        .doc-list {
            list-style: disc;
            margin: 8px 0 8px 16px; /* add space from card edge */
            padding-left: 16px;     /* ensure bullets are not flush left */
        }
        .doc-list li {
            margin: 6px 0;
        }
    </style>
</head>
<body>
<div class="header">
    <h1>🌉 JavaScript Bridge Demo</h1>
    <p>Bidirectional JavaScript ↔ Native Communication</p>
</div>

<div class="status" id="bridgeStatus">
    <div class="status-dot"></div>
    <span>Bridge Ready</span>
</div>

<!-- Collapsible Documentation Card -->
<div class="section">
    <details class="collapsible">
        <summary>📘 JavaScript Bridge Specification</summary>
        <div class="collapsible-content">
            <div class="device-info" style="display:block; margin-top:8px;">
                <div class="device-info-item"><strong>Global:</strong> <span>window.bridge</span></div>
                <div class="device-info-item"><strong>Schema:</strong> <span class="flex-col"><code class="badge">window.bridge.schemaVersion</code><span class="device-info-subtext">Auto‑attached to every message</span></span></div>
                <div class="device-info-item"><strong>Platform:</strong> <span>WKWebView (iOS)</span></div>
            </div>

            <h3 style="margin-top:12px; font-size:14px; color:#1f2937;">Getting started</h3>
            <pre><code>// Wait for the bridge to be ready (recommended at app start)
await window.bridge.ready();

// Optional: Enable verbose logging from JS side
window.bridge.setDebug(true);

// Optionally listen for native → web messages
window.bridge.on(async (message) => {
  const { action, content } = message.data || {};
  if (action === 'onPushNotification') {
    // ... handle push notification ...
  }
});

window.addEventListener('bridgeReady', () => {
  // bridge is ready; window.bridge is available
});</code></pre>

            <h3 style="margin-top:12px; font-size:14px; color:#1f2937;">API</h3>
            <ul class="doc-list">
                <li>
                    <strong>bridge.ready(): Promise&lt;void&gt;</strong> — resolves when the bridge is initialized.
                </li>
                <li>
                    <strong>bridge.setDebug(enabled: boolean)</strong> — enables/disables JS-side debug logging.
                </li>
                <li>
                    <strong>bridge.call(message, options?): Promise&lt;any&gt;</strong>
                    <div style="margin-top:4px;">
                        <em>message</em> must have the shape:
                        <pre><code>{
  data: {
    action: string,          // required
    content?: object         // optional, depends on action
  }
}</code></pre>
                        <em>options</em> supports:
                        <pre><code>{
  timeout?: number // ms; default 30000
}</code></pre>
                    </div>
                </li>
                <li>
                    <strong>bridge.on(handler: (message) =&gt; any)</strong> — registers a handler for native → web messages.
                </li>
            </ul>

            <h3 style="margin-top:12px; font-size:14px; color:#1f2937;">Message format (native-facing)</h3>
            <pre><code>// Automatically constructed and sent by the bridge
{
  version: window.bridge.schemaVersion, // set by native; cannot be overridden
  id: "msg_...",                        // unique per call
  data: {
    action: "...",                      // required
    content: { ... }                     // optional; per-action schema
  }
}</code></pre>



            <h3 style="margin-top:12px; font-size:14px; color:#1f2937;">Error handling & timeouts</h3>
            <pre><code>try {
  const info = await bridge.call({ data: { action: 'deviceInfo' } }, { timeout: 5000 });
} catch (e) {
  // e.message may contain 'Request timeout after ...ms' or a native error message
}</code></pre>

            <h3 style="margin-top:12px; font-size:14px; color:#1f2937;">Versioning</h3>
            <pre><code>// Read-only schema version negotiated by native
const v = window.bridge.schemaVersion;

// The version is automatically attached to all calls by the bridge and
// cannot be overridden from JavaScript. Use it for capability checks:
if (v &gt;= 2) {
  // use newer APIs
} else {
  // fall back
}</code></pre>


        </div>
    </details>
</div>

<!-- Console Section (moved near top under spec) -->
<div class="section">
    <h2>💻 Console Output</h2>
    <div class="console" id="console">
        <div class="console-entry">
            <span class="timestamp">[--:--:--]</span>
            <span class="info">Console ready. Waiting for bridge...</span>
        </div>
    </div>
    <button class="clear-console" onclick="clearConsole()">Clear Console</button>
</div>

<!-- Device Information Section -->
<div class="section">
    <h2>📱 Device & System</h2>
    <div class="button-group">
        <button onclick="getDeviceInfo()">Device Info</button>
        <button onclick="checkNetwork()">Network Status</button>
        <button onclick="openSettings()">Open Settings</button>
    </div>
    <div id="deviceInfo" class="device-info" style="display: none;"></div>
    <details class="collapsible" style="margin-top:12px;">
        <summary>📘 Spec & Usage</summary>
        <div class="collapsible-content">
                <pre><code>// deviceInfo (no content). Returns device/app info object.
await bridge.call({ data: { action: 'deviceInfo' } });

// networkState (no content). Returns { connected: boolean, type?: string }.
await bridge.call({ data: { action: 'networkState' } });

// openSettings (no content). Opens the system settings where supported.
await bridge.call({ data: { action: 'openSettings' } });</code></pre>
        </div>
    </details>
</div>

<!-- UI Actions Section -->
<div class="section">
    <h2>🎨 UI Actions</h2>
    <div class="button-group">
        <button onclick="showToast()">Show Toast</button>
        <button onclick="showAlert()">Show Alert</button>
    </div>
    <details class="collapsible" style="margin-top:12px;">
        <summary>📘 Spec & Usage</summary>
        <div class="collapsible-content">
                <pre><code>// showToast — content.message is required; content.duration optional ('short' | 'long')
await bridge.call({
  data: {
    action: 'showToast',
    content: { message: 'Hello 👋', duration: 'short' }
  }
});

// showAlert — content.title and content.message are required; content.buttons optional
await bridge.call({
  data: {
    action: 'showAlert',
    content: { title: 'Title', message: 'Message', buttons: ['OK', 'Cancel'] }
  }
});</code></pre>
        </div>
    </details>
</div>

<!-- Top Navigation Section -->
<div class="section">
    <h2>📱 Top Navigation</h2>
    <div class="button-group">
        <button onclick="toggleTopNav()">Toggle Visibility</button>
        <button onclick="setTopNavTitle()">Set Title</button>
        <button onclick="toggleUpArrow()">Toggle Back Arrow</button>
        <button onclick="toggleDivider()">Toggle Divider</button>
        <button onclick="toggleLogo()">Toggle Logo</button>
        <button onclick="toggleProfile()">Toggle Profile</button>
    </div>
    <details class="collapsible" style="margin-top:12px;">
        <summary>📘 Spec & Usage</summary>
        <div class="collapsible-content">
                <pre><code>// Toggle/show/hide/update top navigation
await bridge.call({
  data: {
    action: 'topNavigation',
    content: {
      isVisible: boolean,          // optional; omit to keep current visibility
      title: 'Screen Title',       // optional (null to hide when logo is shown)
      showUpArrow: false,          // optional
      showDivider: true,           // optional
      showLogo: false,             // optional
      showProfileIconWidget: false // optional
    }
  }
});</code></pre>
        </div>
    </details>
</div>

<!-- Bottom Navigation Section -->
<div class="section">
    <h2>🗂️ Bottom Navigation</h2>
    <div class="button-group">
        <button onclick="toggleBottomNav()">Toggle Visibility</button>
        <button onclick="showBottomNav()">Show Bottom Nav</button>
        <button onclick="hideBottomNav()">Hide Bottom Nav</button>
    </div>
    <details class="collapsible" style="margin-top:12px;">
        <summary>📘 Spec & Usage</summary>
        <div class="collapsible-content">
                <pre><code>// Show/hide bottom navigation
await bridge.call({
  data: { action: 'bottomNavigation', content: { isVisible: true } }
});</code></pre>
        </div>
    </details>
</div>

<!-- System Bars Section -->
<div class="section">
    <h2>🖥️ System Bars</h2>
    <div class="button-group">
        <button onclick="toggleStatusBar()">Toggle Status Bar</button>
        <button onclick="toggleSystemNav()">Toggle System Nav</button>
        <button onclick="hideAllBars()">Hide All Bars</button>
        <button onclick="showAllBars()">Show All Bars</button>
    </div>
    <div class="test-section">
        <h3>ℹ️ Platform Support</h3>
        <p style="font-size: 13px; color: #78350f; margin-top: 4px;">
            System bars control is fully supported on Android. iOS has platform limitations and does not support these controls.
        </p>
    </div>
    <details class="collapsible" style="margin-top:12px;">
        <summary>📘 Spec & Usage</summary>
        <div class="collapsible-content">
                <pre><code>// iOS may ignore these due to platform limitations
await bridge.call({
  data: {
    action: 'systemBars',
    content: {
      // Both keys are optional; send either or both
      showStatusBar: true,          // optional
      showSystemNavigation: true    // optional
    }
  }
});</code></pre>
        </div>
    </details>
</div>

<!-- Haptic Feedback Section -->
<div class="section">
    <h2>📳 Haptic Feedback</h2>
    <div class="button-group">
        <button onclick="triggerHaptic()">Vibrate</button>
        <button onclick="multipleHaptics()">Multiple Vibrates</button>
    </div>
    <details class="collapsible" style="margin-top:12px;">
        <summary>📘 Spec & Usage</summary>
        <div class="collapsible-content">
                <pre><code>// Simple vibration
await bridge.call({
  data: { action: 'haptic', content: { vibrate: true } }
});</code></pre>
        </div>
    </details>
</div>

<!-- Navigation Section -->
<div class="section">
    <h2>🧭 Navigation</h2>
    <div class="button-group">
        <button onclick="navigateInternal()">Navigate Internal</button>
        <button onclick="navigateExternal()">Navigate External</button>
        <button onclick="goBack()">Go Back</button>
    </div>
    <details class="collapsible" style="margin-top:12px;">
        <summary>📘 Spec & Usage</summary>
        <div class="collapsible-content">
                <pre><code>// Open URL internally (in-app)
await bridge.call({
  data: { action: 'navigation', content: { url: 'https://www.check24.de', external: false } }
});

// Open URL externally (browser)
await bridge.call({
  data: { action: 'navigation', content: { url: 'https://www.check24.de', external: true } }
});

// Go back
await bridge.call({
  data: { action: 'navigation', content: { goBack: true } }
});</code></pre>
        </div>
    </details>
</div>

<!-- System Actions Section -->
<div class="section">
    <h2>⚙️ System Actions</h2>
    <div class="button-group">
        <button onclick="copyToClipboard()">Copy Text</button>
    </div>
    <details class="collapsible" style="margin-top:12px;">
        <summary>📘 Spec & Usage</summary>
        <div class="collapsible-content">
                <pre><code>// Copy text to clipboard
await bridge.call({
  data: { action: 'copyToClipboard', content: { text: 'Hello' } }
});</code></pre>
        </div>
    </details>
</div>

<!-- Lifecycle Events Section -->
<div class="section">
    <h2>🔄 Lifecycle Events</h2>
    <div class="button-group">
        <button onclick="enableLifecycle()">Enable Events</button>
        <button onclick="disableLifecycle()">Disable Events</button>
    </div>
    <div class="test-section">
        <h3>ℹ️ Lifecycle Events</h3>
        <p style="font-size: 13px; color: #78350f; margin-top: 4px;">
            Enable to receive lifecycle events from the native side. Currently sends focus and unfocus events based on whether the screen has focus (both Android and iOS).
        </p>
    </div>
    <details class="collapsible" style="margin-top:12px;">
        <summary>📘 Spec & Usage</summary>
        <div class="collapsible-content">
                <pre><code>// Enable/disable native → web lifecycle events (focus/unfocus)
await bridge.call({ data: { action: 'lifecycleEvents', content: { enable: true } } });
await bridge.call({ data: { action: 'lifecycleEvents', content: { enable: false } } });

// Listen for lifecycle events from native (focused/defocused)
window.bridge.on((message) => {
  const { action, content } = message.data || {};
  if (action === 'lifecycle') {
    if (content?.event === 'focused') {
      // handle focus gained
    } else if (content?.event === 'defocused') {
      // handle focus lost
    }
  }
});</code></pre>
        </div>
    </details>
</div>

<!-- Refresh Events Section -->
<div class="section">
    <h2>🔔 Refresh Events</h2>
    <div class="button-group">
        <button onclick="startListeningRefresh()">Start Listening</button>
        <button onclick="stopListeningRefresh()">Stop Listening</button>
        <button onclick="triggerRefresh()">Trigger Refresh</button>
    </div>
    <div class="test-section">
        <h3>ℹ️ Push Notification Events</h3>
        <p style="font-size: 13px; color: #78350f; margin-top: 4px;">
            Native listens to the messaging service and pushes events to web after receiving push notifications.
            Start listening to log these events in the console.
        </p>
    </div>
    <details class="collapsible" style="margin-top:12px;">
        <summary>📘 Spec & Usage</summary>
        <div class="collapsible-content">
                <pre><code>// Listen for push notifications sent from native
window.bridge.on((message) => {
  const { action, content } = message.data || {};
  if (action === 'onPushNotification') {
    // e.g. use the URL provided by native
    const url = content?.url;
    // ... handle push event ...
  }
});

// Trigger a refresh command from web (optional)
await bridge.call({ data: { action: 'refresh', content: { command: 'refresh' } } });</code></pre>
        </div>
    </details>
</div>

<!-- Storage Section -->
<div class="section">
    <h2>💾 Secure Storage</h2>
    <div class="button-group">
        <button onclick="saveData()">Save Data</button>
        <button onclick="loadData()">Load Data</button>
        <button onclick="removeData()">Remove Data</button>
    </div>
    <details class="collapsible" style="margin-top:12px;">
        <summary>📘 Spec & Usage</summary>
        <div class="collapsible-content">
                <pre><code>// Save
await bridge.call({
  data: { action: 'saveSecureData', content: { key: 'k', value: 'v' } }
});

// Load → returns { value?: string }
const result = await bridge.call({
  data: { action: 'loadSecureData', content: { key: 'k' } }
});

// Remove
await bridge.call({
  data: { action: 'removeSecureData', content: { key: 'k' } }
});</code></pre>
        </div>
    </details>
</div>

<!-- Analytics Section -->
<div class="section">
    <h2>📊 Analytics (Fire & Forget)</h2>
    <div class="button-group">
        <button onclick="trackEvent()">Track Event</button>
        <button onclick="trackScreen()">Track Screen</button>
    </div>
    <details class="collapsible" style="margin-top:12px;">
        <summary>📘 Spec & Usage</summary>
        <div class="collapsible-content">
                <pre><code>// Track event — no response expected
bridge.call({
  data: {
    action: 'trackEvent',
    content: { event: 'button_click', params: { screen: 'bridge_demo' } }
  }
});

// Track screen — no response expected
bridge.call({
  data: {
    action: 'trackScreen',
    content: { screenName: 'Bridge Demo', screenClass: 'BridgeDemoScreen' }
  }
});</code></pre>
        </div>
    </details>
</div>

<!-- Bidirectional Communication Section -->
<div class="section">
    <h2>🔄 Bidirectional Communication</h2>
    <div class="button-group">
        <button onclick="testNativeToWeb()">Test Native→Web</button>
        <button onclick="testWebToNative()">Test Web→Native</button>
    </div>
    <div class="test-section">
        <h3>ℹ️ About Bidirectional Communication</h3>
        <p style="font-size: 13px; color: #78350f; margin-top: 4px;">
            The bridge supports both directions: Web can call Native (like all buttons above),
            and Native can send messages to Web (event notifications, data updates).
        </p>
    </div>
</div>

<!-- Schema Versioning Section -->
<div class="section">
    <h2>🔢 Schema Versioning</h2>
    <div class="button-group">
        <button onclick="checkSchemaVersion()">Check Schema</button>
        <button onclick="testVersionCompatibility()">Test Compatibility</button>
        <button onclick="testFutureVersion()">Test Future Version</button>
    </div>
    <div class="test-section">
        <h3>ℹ️ About Schema Versioning</h3>
        <p style="font-size: 13px; color: #78350f; margin-top: 4px;">
            Schema version is a simple integer (1, 2, 3...) that increments on breaking changes.
            Web can check the version and use appropriate APIs. If web sends a higher version than native supports, native silently ignores the call.
        </p>
    </div>
</div>

<!-- Test Suite Section -->
<div class="section">
    <h2>🧪 Automated Tests</h2>
    <div class="button-group">
        <button onclick="runAllTests()">Run All Tests</button>
        <button onclick="testFireAndForget()">Test Fire & Forget</button>
        <button onclick="testErrorHandling()">Test Errors</button>
    </div>
</div>

<!-- Specification Section (removed; content distributed within sections) -->


<script>
    // Console management
    const consoleEl = document.getElementById('console');
    const maxConsoleEntries = 50;

    function log(message, type = 'info') {
        const timestamp = new Date().toLocaleTimeString();
        const entry = document.createElement('div');
        entry.className = `console-entry ${type}`;
        entry.innerHTML = `<span class="timestamp">[${timestamp}]</span><span>${message}</span>`;

        consoleEl.insertBefore(entry, consoleEl.firstChild);

        // Limit console entries
        while (consoleEl.children.length > maxConsoleEntries) {
            consoleEl.removeChild(consoleEl.lastChild);
        }
    }

    function clearConsole() {
        consoleEl.innerHTML = '<div class="console-entry"><span class="info">Console cleared</span></div>';
    }

    // Initialize bridge
    let bridgeReady = false;

    async function initBridge() {
        try {
            await window.bridge.ready();
            bridgeReady = true;
            log('✅ Bridge initialized successfully', 'success');
            log('🔢 Schema version: ' + window.bridge.schemaVersion, 'info');

            // Set up message listener
            window.bridge.on(handleNativeMessage);
            log('📨 Listening for native messages...', 'info');

            document.getElementById('bridgeStatus').innerHTML =
                '<div class="status-dot"></div><span>Bridge Ready (Schema v' + window.bridge.schemaVersion + ')</span>';
        } catch (e) {
            log('❌ Bridge initialization failed: ' + e.message, 'error');
            document.getElementById('bridgeStatus').innerHTML =
                '<div class="status-dot" style="background: #ef4444;"></div><span>Bridge Error</span>';
        }
    }

    // Handle messages from native
    let isListeningToRefresh = false;

    async function handleNativeMessage(message) {
        const { action, content } = message.data || {};

        // Handle push notifications - only log if listening
        if (action === 'onPushNotification') {
            if (isListeningToRefresh) {
                log('🔔 Push Notification: ' + (content?.message || 'No message'), 'success');
            }
            return { status: 'received', handled: true };
        }

        // Log other messages from native
        log('📨 Message from native: ' + JSON.stringify(message), 'info');

        if (action === 'ping') {
            log('🏓 Received ping, sending pong...', 'info');
            return { pong: true, timestamp: Date.now() };
        }

        if (action === 'notification') {
            log('🔔 Notification: ' + (content?.message || 'No message'), 'info');
        }

        return { status: 'received', handled: true };
    }

    // Device Information
    async function getDeviceInfo() {
        try {
            log('📱 Requesting device info...', 'info');
            const info = await window.bridge.call({
                data: { action: 'deviceInfo' }
            });

            log('✅ Device info received', 'success');

            const deviceInfoEl = document.getElementById('deviceInfo');
            deviceInfoEl.style.display = 'block';
            deviceInfoEl.innerHTML = `
                <div class="device-info-item"><strong>Platform:</strong> <span>${info.platform || 'Unknown'}</span></div>
                <div class="device-info-item"><strong>OS Version:</strong> <span>${info.osVersion || 'Unknown'}</span></div>
                <div class="device-info-item"><strong>SDK Version:</strong> <span>${info.sdkVersion || 'Unknown'}</span></div>
                <div class="device-info-item"><strong>Manufacturer:</strong> <span>${info.manufacturer || 'Unknown'}</span></div>
                <div class="device-info-item"><strong>Model:</strong> <span>${info.model || 'Unknown'}</span></div>
                <div class="device-info-item"><strong>App Version:</strong> <span>${info.appVersion || 'Unknown'}</span></div>
            `;
        } catch (e) {
            log('❌ Error: ' + e.message, 'error');
        }
    }

    async function checkNetwork() {
        try {
            log('🌐 Checking network status...', 'info');
            const status = await window.bridge.call({
                data: { action: 'networkState' }
            });

            const emoji = status.connected ? '✅' : '❌';
            log(`${emoji} Network: ${status.connected ? 'Connected' : 'Disconnected'} (${status.type || 'unknown'})`, 'success');
        } catch (e) {
            log('❌ Error: ' + e.message, 'error');
        }
    }

    async function openSettings() {
        try {
            log('⚙️ Opening settings...', 'info');
            await window.bridge.call({
                data: { action: 'openSettings' }
            });
            log('✅ Settings opened', 'success');
        } catch (e) {
            log('❌ Error: ' + e.message, 'error');
        }
    }

    // UI Actions
    async function showToast() {
        try {
            log('🍞 Showing toast...', 'info');
            await window.bridge.call({
                data: {
                    action: 'showToast',
                    content: {
                        message: 'Hello from WebView! 👋',
                        duration: 'short'
                    }
                }
            });
            log('✅ Toast shown', 'success');
        } catch (e) {
            log('❌ Error: ' + e.message, 'error');
        }
    }

    async function showAlert() {
        try {
            log('🚨 Showing alert dialog...', 'info');
            await window.bridge.call({
                data: {
                    action: 'showAlert',
                    content: {
                        title: 'Bridge Demo',
                        message: 'This is a native Android alert dialog triggered from JavaScript!',
                        buttons: ['OK', 'Cancel']
                    }
                }
            });
            log('✅ Alert shown', 'success');
        } catch (e) {
            log('❌ Error: ' + e.message, 'error');
        }
    }

    // Top Navigation Control
    let topNavVisible = true;
    let upArrowVisible = false;
    let dividerVisible = true;
    let logoVisible = false;
    let profileVisible = false;

    async function toggleTopNav() {
        try {
            topNavVisible = !topNavVisible;
            log(`📱 ${topNavVisible ? 'Showing' : 'Hiding'} top navigation...`, 'info');
            await window.bridge.call({
                data: {
                    action: 'topNavigation',
                    content: {
                        isVisible: topNavVisible,
                        title: 'Bridge Demo',
                        showUpArrow: upArrowVisible,
                        showDivider: dividerVisible,
                        showLogo: logoVisible,
                        showProfileIconWidget: profileVisible
                    }
                }
            });
            log(`✅ Top navigation ${topNavVisible ? 'shown' : 'hidden'}`, 'success');
        } catch (e) {
            log('❌ Error: ' + e.message, 'error');
        }
    }

    async function setTopNavTitle() {
        try {
            const title = 'Bridge Demo ' + new Date().toLocaleTimeString();
            log('📝 Setting top navigation title...', 'info');
            await window.bridge.call({
                data: {
                    action: 'topNavigation',
                    content: {
                        isVisible: true,
                        title: title,
                        showUpArrow: upArrowVisible,
                        showDivider: dividerVisible,
                        showLogo: logoVisible,
                        showProfileIconWidget: profileVisible
                    }
                }
            });
            log('✅ Title set: ' + title, 'success');
        } catch (e) {
            log('❌ Error: ' + e.message, 'error');
        }
    }

    async function toggleUpArrow() {
        try {
            upArrowVisible = !upArrowVisible;
            log(`🔙 ${upArrowVisible ? 'Showing' : 'Hiding'} up arrow...`, 'info');
            await window.bridge.call({
                data: {
                    action: 'topNavigation',
                    content: {
                        isVisible: topNavVisible,
                        title: 'Bridge Demo',
                        showUpArrow: upArrowVisible,
                        showDivider: dividerVisible,
                        showLogo: logoVisible,
                        showProfileIconWidget: profileVisible
                    }
                }
            });
            log(`✅ Up arrow ${upArrowVisible ? 'shown' : 'hidden'}`, 'success');
        } catch (e) {
            log('❌ Error: ' + e.message, 'error');
        }
    }

    async function toggleDivider() {
        try {
            dividerVisible = !dividerVisible;
            log(`➖ ${dividerVisible ? 'Showing' : 'Hiding'} divider...`, 'info');
            await window.bridge.call({
                data: {
                    action: 'topNavigation',
                    content: {
                        isVisible: topNavVisible,
                        title: 'Bridge Demo',
                        showUpArrow: upArrowVisible,
                        showDivider: dividerVisible,
                        showLogo: logoVisible,
                        showProfileIconWidget: profileVisible
                    }
                }
            });
            log(`✅ Divider ${dividerVisible ? 'shown' : 'hidden'}`, 'success');
        } catch (e) {
            log('❌ Error: ' + e.message, 'error');
        }
    }

    async function toggleLogo() {
        try {
            logoVisible = !logoVisible;
            log(`🏷️ ${logoVisible ? 'Showing' : 'Hiding'} logo...`, 'info');
            await window.bridge.call({
                data: {
                    action: 'topNavigation',
                    content: {
                        isVisible: topNavVisible,
                        title: logoVisible ? null : 'Bridge Demo',
                        showUpArrow: upArrowVisible,
                        showDivider: dividerVisible,
                        showLogo: logoVisible,
                        showProfileIconWidget: profileVisible
                    }
                }
            });
            log(`✅ Logo ${logoVisible ? 'shown' : 'hidden'}`, 'success');
        } catch (e) {
            log('❌ Error: ' + e.message, 'error');
        }
    }

    async function toggleProfile() {
        try {
            profileVisible = !profileVisible;
            log(`👤 ${profileVisible ? 'Showing' : 'Hiding'} profile icon...`, 'info');
            await window.bridge.call({
                data: {
                    action: 'topNavigation',
                    content: {
                        isVisible: topNavVisible,
                        title: 'Bridge Demo',
                        showUpArrow: upArrowVisible,
                        showDivider: dividerVisible,
                        showLogo: logoVisible,
                        showProfileIconWidget: profileVisible
                    }
                }
            });
            log(`✅ Profile icon ${profileVisible ? 'shown' : 'hidden'}`, 'success');
        } catch (e) {
            log('❌ Error: ' + e.message, 'error');
        }
    }

    // Bottom Navigation Control
    // Initialize to false since screen starts with bottom nav disabled
    let bottomNavVisible = true;

    async function toggleBottomNav() {
        try {
            bottomNavVisible = !bottomNavVisible;
            log(`🗂️ ${bottomNavVisible ? 'Showing' : 'Hiding'} bottom navigation...`, 'info');
            await window.bridge.call({
                data: {
                    action: 'bottomNavigation',
                    content: { isVisible: bottomNavVisible }
                }
            });
            log(`✅ Bottom navigation ${bottomNavVisible ? 'shown' : 'hidden'}`, 'success');
        } catch (e) {
            log('❌ Error: ' + e.message, 'error');
        }
    }

    async function showBottomNav() {
        try {
            bottomNavVisible = true;
            log('🗂️ Showing bottom navigation...', 'info');
            await window.bridge.call({
                data: {
                    action: 'bottomNavigation',
                    content: { isVisible: true }
                }
            });
            log('✅ Bottom navigation shown', 'success');
        } catch (e) {
            log('❌ Error: ' + e.message, 'error');
        }
    }

    async function hideBottomNav() {
        try {
            bottomNavVisible = false;
            log('🗂️ Hiding bottom navigation...', 'info');
            await window.bridge.call({
                data: {
                    action: 'bottomNavigation',
                    content: { isVisible: false }
                }
            });
            log('✅ Bottom navigation hidden', 'success');
        } catch (e) {
            log('❌ Error: ' + e.message, 'error');
        }
    }

    // System Bars Control
    let statusBarVisible = true;
    let systemNavVisible = true;

    async function toggleStatusBar() {
        try {
            statusBarVisible = !statusBarVisible;
            log(`📱 ${statusBarVisible ? 'Showing' : 'Hiding'} status bar...`, 'info');
            await window.bridge.call({
                data: {
                    action: 'systemBars',
                    content: {
                        showStatusBar: statusBarVisible,
                        showSystemNavigation: systemNavVisible
                    }
                }
            });
            log(`✅ Status bar ${statusBarVisible ? 'shown' : 'hidden'}`, 'success');
        } catch (e) {
            log('❌ Error: ' + e.message, 'error');
        }
    }

    async function toggleSystemNav() {
        try {
            systemNavVisible = !systemNavVisible;
            log(`🖥️ ${systemNavVisible ? 'Showing' : 'Hiding'} system navigation...`, 'info');
            await window.bridge.call({
                data: {
                    action: 'systemBars',
                    content: {
                        showStatusBar: statusBarVisible,
                        showSystemNavigation: systemNavVisible
                    }
                }
            });
            log(`✅ System navigation ${systemNavVisible ? 'shown' : 'hidden'}`, 'success');
        } catch (e) {
            log('❌ Error: ' + e.message, 'error');
        }
    }

    async function hideAllBars() {
        try {
            statusBarVisible = false;
            systemNavVisible = false;
            log('🖥️ Hiding all system bars...', 'info');
            await window.bridge.call({
                data: {
                    action: 'systemBars',
                    content: {
                        showStatusBar: false,
                        showSystemNavigation: false
                    }
                }
            });
            log('✅ All system bars hidden', 'success');
        } catch (e) {
            log('❌ Error: ' + e.message, 'error');
        }
    }

    async function showAllBars() {
        try {
            statusBarVisible = true;
            systemNavVisible = true;
            log('🖥️ Showing all system bars...', 'info');
            await window.bridge.call({
                data: {
                    action: 'systemBars',
                    content: {
                        showStatusBar: true,
                        showSystemNavigation: true
                    }
                }
            });
            log('✅ All system bars shown', 'success');
        } catch (e) {
            log('❌ Error: ' + e.message, 'error');
        }
    }

    // Haptic Feedback
    async function triggerHaptic() {
        try {
            log('📳 Triggering haptic feedback...', 'info');
            await window.bridge.call({
                data: {
                    action: 'haptic',
                    content: { vibrate: true }
                }
            });
            log('✅ Haptic feedback triggered', 'success');
        } catch (e) {
            log('❌ Error: ' + e.message, 'error');
        }
    }

    async function multipleHaptics() {
        try {
            log('📳 Triggering multiple haptics...', 'info');
            for (let i = 0; i < 3; i++) {
                await window.bridge.call({
                    data: {
                        action: 'haptic',
                        content: { vibrate: true }
                    }
                });
                await new Promise(resolve => setTimeout(resolve, 200));
            }
            log('✅ Multiple haptics triggered', 'success');
        } catch (e) {
            log('❌ Error: ' + e.message, 'error');
        }
    }

    // Navigation Control
    async function navigateInternal() {
        try {
            log('🧭 Navigating internally...', 'info');
            await window.bridge.call({
                data: {
                    action: 'navigation',
                    content: {
                        url: 'https://www.check24.de',
                        external: false
                    }
                }
            });
            log('✅ Internal navigation triggered', 'success');
        } catch (e) {
            log('❌ Error: ' + e.message, 'error');
        }
    }

    async function navigateExternal() {
        try {
            log('🌐 Opening external browser...', 'info');
            await window.bridge.call({
                data: {
                    action: 'navigation',
                    content: {
                        url: 'https://www.check24.de',
                        external: true
                    }
                }
            });
            log('✅ External browser opened', 'success');
        } catch (e) {
            log('❌ Error: ' + e.message, 'error');
        }
    }

    async function goBack() {
        try {
            log('⬅️ Going back...', 'info');
            await window.bridge.call({
                data: {
                    action: 'navigation',
                    content: { goBack: true }
                }
            });
            log('✅ Back navigation triggered', 'success');
        } catch (e) {
            log('❌ Error: ' + e.message, 'error');
        }
    }

    // Lifecycle Events
    async function enableLifecycle() {
        try {
            log('🔄 Enabling lifecycle events...', 'info');
            await window.bridge.call({
                data: {
                    action: 'lifecycleEvents',
                    content: { enable: true }
                }
            });
            log('✅ Lifecycle events enabled (watch console for events)', 'success');
        } catch (e) {
            log('❌ Error: ' + e.message, 'error');
        }
    }

    async function disableLifecycle() {
        try {
            log('🔄 Disabling lifecycle events...', 'info');
            await window.bridge.call({
                data: {
                    action: 'lifecycleEvents',
                    content: { enable: false }
                }
            });
            log('✅ Lifecycle events disabled', 'success');
        } catch (e) {
            log('❌ Error: ' + e.message, 'error');
        }
    }

    // Refresh Events
    function startListeningRefresh() {
        isListeningToRefresh = true;
        log('🔔 Started listening to push notification events...', 'success');
        log('ℹ️ Native sends events every 5 seconds. Watch for green messages.', 'info');
    }

    function stopListeningRefresh() {
        isListeningToRefresh = false;
        log('🔕 Stopped listening to push notification events', 'warning');
    }

    async function triggerRefresh() {
        try {
            log('🔄 Triggering refresh with refresh command...', 'info');
            await window.bridge.call({
                data: {
                    action: 'refresh',
                    content: { command: 'refresh' }
                }
            });
            log('✅ Refresh command sent successfully', 'success');
        } catch (e) {
            log('❌ Error: ' + e.message, 'error');
        }
    }

    // System Actions
    async function copyToClipboard() {
        try {
            log('📋 Copying to clipboard...', 'info');
            const text = 'JavaScript Bridge - ' + new Date().toISOString();
            await window.bridge.call({
                data: {
                    action: 'copyToClipboard',
                    content: { text }
                }
            });
            log('✅ Copied: ' + text, 'success');
        } catch (e) {
            log('❌ Error: ' + e.message, 'error');
        }
    }

    // Storage
    async function saveData() {
        try {
            log('💾 Saving secure data...', 'info');
            await window.bridge.call({
                data: {
                    action: 'saveSecureData',
                    content: {
                        key: 'demo_key',
                        value: 'Bridge Demo Data - ' + new Date().toISOString()
                    }
                }
            });
            log('✅ Data saved', 'success');
        } catch (e) {
            log('❌ Error: ' + e.message, 'error');
        }
    }

    async function loadData() {
        try {
            log('📂 Loading secure data...', 'info');
            const result = await window.bridge.call({
                data: {
                    action: 'loadSecureData',
                    content: { key: 'demo_key' }
                }
            });
            log('✅ Data loaded: ' + JSON.stringify(result), 'success');
        } catch (e) {
            log('❌ Error: ' + e.message, 'error');
        }
    }

    async function removeData() {
        try {
            log('🗑️ Removing secure data...', 'info');
            await window.bridge.call({
                data: {
                    action: 'removeSecureData',
                    content: { key: 'demo_key' }
                }
            });
            log('✅ Data removed', 'success');
        } catch (e) {
            log('❌ Error: ' + e.message, 'error');
        }
    }

    // Analytics (Fire and Forget)
    function trackEvent() {
        log('📊 Tracking event (fire & forget)...', 'info');
        window.bridge.call({
            data: {
                action: 'trackEvent',
                content: {
                    event: 'button_click',
                    params: {
                        button_name: 'track_event',
                        screen: 'bridge_demo',
                        timestamp: new Date().toISOString()
                    }
                }
            }
        });
        log('✅ Event tracked (no response expected)', 'success');
    }

    function trackScreen() {
        log('📊 Tracking screen view (fire & forget)...', 'info');
        window.bridge.call({
            data: {
                action: 'trackScreen',
                content: {
                    screenName: 'Bridge Demo',
                    screenClass: 'BridgeDemoScreen'
                }
            }
        });
        log('✅ Screen tracked (no response expected)', 'success');
    }

    // Bidirectional Communication Tests
    function testNativeToWeb() {
        log('🔄 Requesting native to send test message...', 'info');
        log('⚠️ This requires native code to call sendToWeb()', 'warning');
        log('Example: javaScriptBridge?.sendToWeb("notification", mapOf("message" to "Test from native"))', 'info');
    }

    async function testWebToNative() {
        try {
            log('🔄 Testing Web→Native communication...', 'info');
            const result = await window.bridge.call({
                data: {
                    action: 'deviceInfo'
                }
            }, { timeout: 5000 });
            log('✅ Web→Native test successful: ' + result.platform, 'success');
        } catch (e) {
            log('❌ Error: ' + e.message, 'error');
        }
    }

    // Test Suite
    async function runAllTests() {
        log('🧪 Running all tests...', 'info');

        const tests = [
            { name: 'Device Info', fn: getDeviceInfo },
            { name: 'Network Status', fn: checkNetwork },
            { name: 'Toast', fn: showToast },
            { name: 'Clipboard', fn: copyToClipboard },
            { name: 'Haptic', fn: triggerHaptic },
            { name: 'Toggle Top Nav', fn: toggleTopNav },
            { name: 'Toggle Bottom Nav', fn: toggleBottomNav },
        ];

        let passed = 0;
        let failed = 0;

        for (const test of tests) {
            try {
                await test.fn();
                passed++;
                await new Promise(resolve => setTimeout(resolve, 500)); // Small delay between tests
            } catch (e) {
                failed++;
                log(`❌ Test "${test.name}" failed: ${e.message}`, 'error');
            }
        }

        log(`📊 Test Results: ${passed} passed, ${failed} failed`, passed === tests.length ? 'success' : 'warning');
    }

    function testFireAndForget() {
        log('🧪 Testing fire-and-forget pattern...', 'info');
        trackEvent();
        trackScreen();
        log('✅ Fire-and-forget test complete (no responses expected)', 'success');
    }

    async function testErrorHandling() {
        log('🧪 Testing error handling...', 'info');

        try {
            await window.bridge.call({
                data: { action: 'nonExistentAction' }
            });
        } catch (e) {
            log('✅ Error handling works: ' + e.message, 'success');
            return;
        }

        log('❌ Error handling failed - no error was thrown', 'error');
    }

    // Schema Versioning Tests
    function checkSchemaVersion() {
        log('🔢 Checking schema version...', 'info');
        log('🔢 Schema version: ' + window.bridge.schemaVersion, 'success');
        log('ℹ️ All messages automatically include version ' + window.bridge.schemaVersion, 'info');
    }

    async function testVersionCompatibility() {
        log('🧪 Testing version compatibility...', 'info');

        const currentVersion = window.bridge.schemaVersion;
        log('📋 Current schema version: ' + currentVersion, 'info');

        // Test with current version (should work)
        try {
            log('✅ Testing with version ' + currentVersion + ' (current)...', 'info');
            await window.bridge.call({
                data: { action: 'deviceInfo' }
            }, { version: currentVersion });
            log('✅ Version ' + currentVersion + ' works as expected', 'success');
        } catch (e) {
            log('❌ Error with current version: ' + e.message, 'error');
        }

        // Example: Backend strategy
        log('ℹ️ Backend strategy example:', 'info');
        if (currentVersion >= 2) {
            log('  → Would use v2 API (new features)', 'info');
        } else {
            log('  → Would use v1 API (legacy)', 'info');
        }
    }

    async function testFutureVersion() {
        log('🧪 Testing with future version (should be silently ignored)...', 'warning');

        const futureVersion = window.bridge.schemaVersion + 1;
        log('📋 Sending message with version ' + futureVersion + '...', 'info');
        log('⚠️ Native will silently ignore this (no error, no response)', 'warning');

        try {
            // This will timeout because native ignores it
            await window.bridge.call({
                data: { action: 'deviceInfo' }
            }, { version: futureVersion, timeout: 3000 });
            log('❌ Unexpected: got a response!', 'error');
        } catch (e) {
            if (e.message.includes('timeout')) {
                log('✅ Correctly timed out - native silently ignored version ' + futureVersion, 'success');
            } else {
                log('⚠️ Different error: ' + e.message, 'warning');
            }
        }
    }

    // Listen for bridgeReady event dispatched by native bridge
    window.addEventListener('bridgeReady', () => {
        log('🚀 Bridge ready event received', 'info');
        if (!bridgeReady) {
            initBridge();
        }
    });
</script>
</body>
</html>

